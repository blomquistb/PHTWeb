<!--
Featue Todo:

    Add map change history and ability to undo operations.
    Add undo/redo buffer to all actions that effect mapping table: setting / locking entry, clicking on word in results, clicking solve button.

    The GetWordCounts() method does not combine the counts from local with database properly, it needs to add exclude patterns for all words that match in local
    to the database query.

    Display a list of all duplicate encrypted words with counts and allow them to be highlighted in decrypted text area.

    Add code for trying to remove 'S' from end if search comes up empty with 'S' similar to how the "'S" code works.
-->

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Cryptogram Helper</title>
    <script src="/es6-shim.js"></script>
    <script src="/jquery-2.1.4.js"></script>
    <script src="/Utils.js"></script>    
    <script src="/PHTWords.js"></script>

    <script type="text/javascript">

        ////English letter frequency sequence as  "ETAONRISHDLFCMUGYPWBVKJXQZ"
        ////English letter first letter frequency "TASHWIOBMFCLDPNEGRYUVJKQZX"
        ////common doubled letters "LL EE SS OO TT FF RR NN PP CC"
        ////common letter pairs as "TH HE AN RE ER IN ON AT ND ST ES EN OF TE ED OR TI HI AS TO"

        var gSearchResults = [];
        var gSearchResultsSort = 1;
        var gSearchMapTry = "";
        var gSearchCypher = "";

        var gMapping = [];
        var gMapSorting = 1;
        var gLastAppliedFreq = function (map) {
            map.sort(function (a, b) { if (b.frequency == a.frequency) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.frequency - a.frequency; });
            setAutoApplyHighlight("OccuranceFreqTitle");
            return applyFrequency(map, getOccuranceFreq());
        };

        function doEncryptionChanged() {

            gMapping = getCharacterMap(getOriginalText(), getIgnoreCase(), getExcludeText(), gMapping);

            // Apply last mapping strategy used.
            //
            if (getAutoApply()) {
                gMapping = gLastAppliedFreq(gMapping);
            }

            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function getOriginalText() {
            return unEscapeHtml(document.getElementById("Encrypted").innerHTML);
        }

        function getCharacterMap(encryptedText, ignoreCase, excludeText, oldMap) {
            var domainChars = "";
            var newMap = [];

            // Calculate new map from encrypted text minus the characters in exludeText.
            //
            var first = true;
            var previousChar = '';
            for (var i = 0; i < encryptedText.length; i++) {
                var encryptedChar = encryptedText.charAt(i);
                if (ignoreCase) {
                    encryptedChar = encryptedChar.toUpperCase();
                }

                if (!excludeText || (excludeText.indexOf(encryptedChar) < 0)) {
                    var index = domainChars.indexOf(encryptedChar);
                    if (index < 0) {
                        newMap.push({ cypher: encryptedChar, key: encryptedChar, frequency: 1, double: 0, first: 0 });
                        domainChars = domainChars + encryptedChar;
                        index = domainChars.length - 1;
                    }
                    else {
                        newMap[index].frequency++;
                        if (previousChar == encryptedChar) {
                            newMap[index].double++;
                        }
                    }

                    if (first) {
                        newMap[index].first = newMap[index].first + 1;
                        first = false;
                    }
                }
                else {
                    if (PHTWords.IsWhitespace(encryptedChar)) {
                        first = true;
                    }
                }

                previousChar = encryptedChar;
            }

            // Copy any remaining locked mappings from the old map to the new map.
            //
            if (oldMap) {
                for (var i = 0; i < newMap.length; i++) {
                    for (var j = 0; j < oldMap.length; j++) {
                        if (newMap[i].cypher == oldMap[j].cypher) {
                            newMap[i].locked = oldMap[j].locked;
                            newMap[i].key = oldMap[j].key;
                            break;
                        }
                    }
                }
            }

            return newMap;
        }

        function decryptText(cypherText, map) {
            var encryptedWord = "";
            var decryptedWord = "";
            var result = "";

            if (getIgnoreCase()) {
                cypherText = cypherText.toUpperCase();
            }

            for (var i = 0; i < cypherText.length; i++) {
                if (PHTWords.IsWhitespace(cypherText.charAt(i))) {
                    if (decryptedWord) {
                        result = result + '<span onclick="doWordClick(\'' + escapeJSLiterial(escapeHtmlAttribute(encryptedWord)) + '\')">' + decryptedWord + '</span>';
                        encryptedWord = "";
                        decryptedWord = "";
                    }
                    result = result + getMapping(cypherText.charAt(i), map);
                }
                else {
                    encryptedWord += cypherText.charAt(i);
                    decryptedWord += getMapping(cypherText.charAt(i), map);
                }
            }

            if (decryptedWord) {
                result = result + '<span onclick="doWordClick(\'' + escapeJSLiterial(escapeHtmlAttribute(encryptedWord)) + '\')">' + decryptedWord + '</span>';
            }

            return result;
        }

        function getMapping(cypherChar, map) {
            var result = cypherChar;

            if (!PHTWords.IsWhitespace(cypherChar)) {
                result = '<span style="color:grey;">' + cypherChar + '</span>';
            }

            for (var i = 0; i < map.length; i++) {
                if (cypherChar == map[i].cypher) {
                    if (map[i].locked) {
                        result = '<span style="color:black;">' + map[i].key + '</span>';
                    }
                    else {
                        result = '<span style="color:orange;">' + map[i].key + '</span>';
                    }

                    break;
                }
            }

            return result;
        }

        function getIgnoreCase() {
            return getIsChecked("IgnoreCase", true);
        }

        function getCryptoAnagram() {
            return getIsChecked("CryptoAnagram", false);
        }

        function getAutoApply() {
            return getIsChecked("AutoApply", false);
        }

        function setAutoApply(value) {
            setIsChecked("AutoApply", value);
        }

        function setAutoApplyHighlight(title) {
            var titles = ["OccuranceFreqTitle", "FirstFreqTitle", "DoubleFreqTitle", "RotateN"];
            for (var i = 0; i < titles.length; i++) {
                var elem = document.getElementById(titles[i]);
                if (elem) {
                    if (titles[i] == title) {
                        elem.style.backgroundColor = "yellow";
                    }
                    else {
                        elem.style.backgroundColor = "inherit";
                    }
                }
            }
        }

        function applyFrequency(map, freqString) {

            var domainArray = [];
            for (var i = 0; i < map.length; i++) {
                domainArray.push(map[i].cypher);
            }
            domainArray.sort(function (a, b) { return a.charCodeAt(0) - b.charCodeAt(0); });
            var domain = domainArray.join('');

            for (var i = 0; i < map.length; i++) {
                if (map[i].locked) {
                    freqString = freqString.replace(new RegExp(map[i].key.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'), 'g'), '');
                    domain = domain.replace(new RegExp(map[i].key.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'), 'g'), '');
                }
            }

            for (var i = 0; i < map.length; i++) {
                if (!map[i].locked) {
                    if (freqString.length > 0) {
                        map[i].key = freqString.substring(0, 1);
                        freqString = freqString.substring(1);
                        domain = domain.replace(new RegExp(map[i].key.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'), 'g'), '');
                    }
                    else if (domain.length > 0) {
                        map[i].key = domain.substring(0, 1);
                        domain = domain.substring(1);
                    }
                    else {
                        map[i].key = '*';
                    }
                }
            }

            return map;
        }

        function getExcludeText() {
            var result = getInputValue("Exclude");

            if (getIsChecked("Numbers")) {
                result = result + PHTWords.Digits;
            }

            if (getIsChecked("Punctuation")) {
                result = result + PHTWords.Punctuation;
            }

            if (getIsChecked("Whitespace")) {
                result = result + PHTWords.Whitespace;
            }

            return result
        }

        function getOccuranceFreq() {
            return getInputValue("OccuranceFreq");
        }

        function getFirstLetterFreq() {
            return getInputValue("FirstFreq");
        }

        function getDoubleFreq() {
            return getInputValue("DoubleFreq");
        }

        function getRotateValue() {
            return getNumericValue("RotateValue", 0);
        }

        function setRotateValue(value) {
            setInputValue("RotateValue", value);
        }

        function doApplyOccurancyFreq() {
            gLastAppliedFreq = function (map) {
                map.sort(function (a, b) { if (b.frequency == a.frequency) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.frequency - a.frequency; });
                setAutoApplyHighlight("OccuranceFreqTitle");
                return applyFrequency(map, getOccuranceFreq());
            };

            gLastAppliedFreq(gMapping);
            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function doApplyFirstFreq() {
            gLastAppliedFreq = function (map) {
                map.sort(function (a, b) { if (b.first == a.first) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.first - a.first });
                setAutoApplyHighlight("FirstFreqTitle");
                return applyFrequency(map, getFirstLetterFreq());
            };

            gLastAppliedFreq(gMapping);
            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function doApplyDoubleFreq() {
            gLastAppliedFreq = function (map) {
                map.sort(function (a, b) { if (b.double == a.double) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.double - a.double });
                setAutoApplyHighlight("DoubleFreqTitle");
                return applyFrequency(map, getDoubleFreq());
            };

            gLastAppliedFreq(gMapping);
            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function doApplyRotateN() {
            gLastAppliedFreq = function (map) {
                setAutoApplyHighlight("RotateN");
                for (var i = 0; i < map.length; i++) {
                    if (!map[i].locked) {
                        var value = map[i].cypher.toUpperCase().charCodeAt(0);
                        value = value - "A".charCodeAt(0);
                        value = value - getRotateValue();
                        value = value % 26;
                        if (value < 0) value += 26;
                        value = value + "A".charCodeAt(0);
                        map[i].key = String.fromCharCode(value);
                    }
                }
                return map;
            };

            gLastAppliedFreq(gMapping);
            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function doSortByOccurancyFreq() {
            gMapSorting = 1;
            renderMappingTable(gMapping);
        }

        function doSortByFirstFreq() {
            gMapSorting = 5;
            renderMappingTable(gMapping);
        }

        function doSortByDoubleFreq() {
            gMapSorting = 2;
            renderMappingTable(gMapping);
        }

        function doSortByDomain() {
            gMapSorting = 3;
            renderMappingTable(gMapping);
        }

        function doSortByKey() {
            gMapSorting = 4;
            renderMappingTable(gMapping);
        }

        function doSortByFrequency() {
            gSearchResultsSort = 1;
            renderSearchResults(gSearchResults);
        }

        function doSortByWords() {
            gSearchResultsSort = 2;
            renderSearchResults(gSearchResults);
        }

        function doFlipMapping(row, word, cypher) {
            if (gSearchMapTry) {
                for (var j = 0; j < gMapping.length; j++) {
                    if (gSearchMapTry.indexOf(gMapping[j].cypher) > -1) {
                        gMapping[j].locked = false;
                    }
                }
                gSearchMapTry = "";
            }


            if (row) {
                if (row.style.backgroundColor == "yellow") {
                    row.style.backgroundColor = "inherit";
                }
                else {
                    // remove highlight from any other cell
                    var table = document.getElementById("MappingTable");

                    for (var i = 0; i < row.parentNode.parentNode.rows.length; i++) {
                        row.parentNode.parentNode.rows[i].style.backgroundColor = "inherit";
                    }

                    row.style.backgroundColor = "yellow";

                    // lock the mapping for this word
                    if (getCryptoAnagram()) {
                        // This will compare the frequency of characters with their mapping and only lock those values that have a unique
                        // mapping.
                        var wordMap = getCharacterMap(word, getIgnoreCase(), getExcludeText());
                        var encryptedMap = getCharacterMap(cypher, getIgnoreCase(), getExcludeText());

                        for (var i = 0; i < encryptedMap.length; i++) {
                            for (var j = 0; j < gMapping.length; j++) {
                                if (gMapping[j].cypher == encryptedMap[i].cypher) {
                                    if (!gMapping[j].locked) {
                                        var values = "";
                                        for (var k = 0; k < wordMap.length; k++) {
                                            if (wordMap[k].frequency == encryptedMap[i].frequency) {
                                                var notMapped = true;
                                                for (var l = 0; l < gMapping.length; l++) {
                                                    if (gMapping[l].locked && (gMapping[l].key == wordMap[k].cypher)) {
                                                        notMapped = false;
                                                        break;
                                                    }
                                                }

                                                if (notMapped) {
                                                    values += wordMap[k].cypher;
                                                }
                                            }
                                        }
                                        if (values.length == 1) {
                                            gSearchMapTry += gMapping[j].cypher;
                                            gMapping[j].key = values;
                                            gMapping[j].locked = true;
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        for (var i = 0; i < word.length; i++) {
                            for (var j = 0; j < gMapping.length; j++) {
                                if (cypher[i] == gMapping[j].cypher) {
                                    if (!gMapping[j].locked) {
                                        gSearchMapTry += gMapping[j].cypher;
                                        gMapping[j].key = word[i];
                                        gMapping[j].locked = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (getAutoApply()) {
                gLastAppliedFreq(gMapping);
            }

            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
        }

        function renderSearchResults(data, startTime) {

            switch (gSearchResultsSort) {
                case 1: { data.sort(function (a, b) { return b.frequency - a.frequency; }); break; }
                case 2: { data.sort(function (a, b) { if (a.value > b.value) { return 1; } else if (a.value < b.value) { return -1; } else { return 0; } }); break; }
            }

            gSearchResults = data;

            var table = document.getElementById("ResultsTable");

            table.innerHTML = '';

            for (var i = 0; i < data.length; i++) {
                var r = table.insertRow(-1);
                if (gSearchCypher) {
                    r.setAttribute("onclick", "doFlipMapping(this,'" + escapeJSLiterial(data[i].value) + "','" + escapeJSLiterial(gSearchCypher) + "');");
                }

                var c = r.insertCell(-1);
                c.innerHTML = data[i].value;

                c = r.insertCell(-1);
                c.style.textAlign = "right";
                c.innerHTML = data[i].frequency;
            }


            if (startTime) {
                setResultsCount(data.length);
                setDuration(new Date().getTime() - startTime);
                beep();
            }
            else {
                setInputValue("ResultsCount", "");
                setDuration(0);
            }
        }

        function renderMappingTable(map) {

            switch (gMapSorting) {
                case 1: map.sort(function (a, b) { if (b.frequency == a.frequency) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.frequency - a.frequency }); break;
                case 2: map.sort(function (a, b) { if (b.double == a.double) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.double - a.double }); break;
                case 3: map.sort(function (a, b) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) }); break;
                case 4: map.sort(function (a, b) { if (b.key.charCodeAt(0) == a.key.charCodeAt(0)) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return a.key.charCodeAt(0) - b.key.charCodeAt(0) }); break;
                case 5: map.sort(function (a, b) { if (b.first == a.first) { return a.cypher.charCodeAt(0) - b.cypher.charCodeAt(0) } return b.first - a.first }); break;
                default: break;
            }

            setInputValue("MapCount", map.length);

            var RotationAdvisory = '';
            var RotationValue = -1;
            for (var i = 0; i < map.length; i++) {
                if (map[i].locked) {
                    var x = (map[i].cypher.charCodeAt(0) - map[i].key.charCodeAt(0) + 26) % 26;
                    if (RotationValue == -1) {
                        RotationValue = x;
                    }
                    else if (RotationValue == x) {
                        RotationAdvisory = "Possible ROT*" + x;
                    }
                    else {
                        RotationAdvisory = '';
                        break;
                    }
                }
            }

            var a = document.getElementById("MappingTableAdvisory");
            if (a) {
                a.innerHTML = RotationAdvisory;
            }

            var t = document.getElementById("MappingTable");
            t.innerHTML = '<tr><th><a href="javascript:void(0)" onclick="doSortByOccurancyFreq();" title="ETAONRISHDLFCMUGYPWBVKJXQZ">Occ</a></th><th><a href="javascript:void(0)" onclick="doSortByFirstFreq();" title="TASHWIOBMFCLDPNEGRYUVJKQZX">Frst</a></th><th><a href="javascript:void(0)" onclick="doSortByDoubleFreq();" title="LESOTFRNPC">Dbl</a></th><th><a href="javascript:void(0)" onclick="doSortByDomain();">Dom</a></th><th><a href="javascript:void(0)" onclick="doSortByKey();">Map</a></th><th>Lock</th></tr>';

            for (var i = 0; i < map.length; i++) {
                var r = t.insertRow(-1);

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = map[i].frequency;

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = map[i].first;

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = map[i].double;

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = map[i].cypher;

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = '<input type="edit" size="1" maxlength="1" onkeyup="doMapChange();" style="text-align: center;" value="' + map[i].key + '"/>'

                c = r.insertCell(-1);
                c.style.textAlign = "center";
                c.innerHTML = '<input type="checkbox" onchange="doLockChange();" value="' + map[i].key + '"' + (map[i].locked ? ' checked' : '') + ' />'
            }
        }

        function renderDecryptedText(map) {
            var decryptedTextArea = document.getElementById("Decrypted");

            decryptedTextArea.innerHTML = decryptText(getOriginalText(), map).replace(/\n/g, '<br />');
        }

        function doMapChange() {
            var table = document.getElementById("MappingTable");

            for (var i = 1, row; row = table.rows[i]; i++) {
                var mapEdit = row.cells[4].firstChild;
                var newValue = mapEdit.value;
                if (getIgnoreCase()) {
                    newValue = newValue.toUpperCase();
                    mapEdit.value = newValue;
                }

                if (gMapping[i - 1].key != newValue) {
                    gMapping[i - 1].key = newValue;
                    gMapping[i - 1].locked = true;
                }
            }

            doEncryptionChanged();
        }

        function doLockChange() {
            var table = document.getElementById("MappingTable");

            for (var i = 1, row; row = table.rows[i]; i++) {
                var mapEdit = row.cells[5].firstChild;
                gMapping[i - 1].locked = mapEdit.checked;
            }

            doEncryptionChanged();
        }

        function doClearMappingLocks() {
            var table = document.getElementById("MappingTable");

            for (var i = 1, row; row = table.rows[i]; i++) {
                var mapEdit = row.cells[5].firstChild;
                mapEdit.checked = false;
                gMapping[i - 1].locked = false;
                gMapping[i - 1].key = gMapping[i - 1].cypher;
            }
        }

        function doSolve() {
            var startTime = new Date().getTime();

            // Get the list of tokens that need to be decrypted.
            //
            var decryptedTextArea = document.getElementById("Decrypted");
            var regEx = /doWordClick\(\'([^)]+)\'\)/g;
            var matches = decryptedTextArea.innerHTML.match(regEx);
            var words = [];
            var counts = [];
            for (var i = 0; i < matches.length; i++) {
                var word = PHTWords.Trim(unEscapeHtmlAttribute(unEscapeJSLiterial(matches[i].substring(13, matches[i].length - 2))), getExcludeText());
                if (word) {
                    var index = words.indexOf(word);
                    if (index == -1) {
                        words.push(word);
                        counts.push(1);
                    }
                    else {
                        counts[index] = counts[index] + 1;
                    }
                }
            }

            if (getCryptoAnagram()) {
                var results = doSolveCryptoAnagram(words, [], getLetterMapping(gMapping));
            }
            else {
                var results = doSolveCryptogram(words, counts);
            }

            renderMappingTable(gMapping);
            renderDecryptedText(gMapping);
            setDuration(new Date().getTime() - startTime);
            beep();
        }

        function getLetterMapping(map) {
            var result = {};

            for (var i = 0; i < map.length; i++) {
                if (map[i].locked) {
                    result[map[i].cypher] = map[i].key;
                }
            }

            return result;
        }

        function doSolveCryptogram(encryptedWords, counts) {

            // base case to exit and display possible solution
            if (encryptedWords.length == 0) {
                var lockCount = 0;
                for (var i = 0; i < gMapping.length; i++) {
                    if (gMapping[i].locked) {
                        lockCount++;
                    }
                }

                if ((lockCount / gMapping.length) > 0.75) {
                    return true;
                }
                else {
                    return false;
                }
            }

            // find best encrypted token to guess at answer
            var occurCount = 0;
            var wordCount = 0;
            var index = -1;

            for (var i = 0; i < encryptedWords.length; i++) {
                var encryptedWord = encryptedWords[i];

                var count = PHTWords.GetWordCounts(getCryptogramPatterns(encryptedWord), null, PHTWords.GetCryptoIdx(encryptedWord), null, null, getDictionaries(), getMinFrequency());

                // Check to see if this might be a possesive form or hyphenated word and remove the hypen to check.
                if (count == 0) {
                    if ((encryptedWord.length > 2) && ("'’".indexOf(encryptedWord.charAt(encryptedWord.length - 2)) > -1)) {
                        encryptedWord = encryptedWord.substring(0, encryptedWord.length - 2);
                        encryptedWords[i] = encryptedWord;
                        count = PHTWords.GetWordCounts(getCryptogramPatterns(encryptedWord), null, PHTWords.GetCryptoIdx(encryptedWord), null, null, getDictionaries(), getMinFrequency());
                    }
                }

                if (count == 1 || count == 0) {
                    occurCount = counts[i];
                    wordCount = count;
                    index = i;
                    break;
                }

                if (counts[i] == occurCount) {
                    if (count < wordCount) {
                        wordCount = count;
                        index = i;
                    }
                }
                else if (counts[i] > occurCount) {
                    occurCount = counts[i];
                    wordCount = count;
                    index = i;
                }
            }

            // get possible words for selected index and apply the pattern and recurse.
            if (wordCount == 0) {
                return doSolveCryptogram(encryptedWords.slice(0, index).concat(encryptedWords.slice(index + 1)), counts.slice(0, index).concat(counts.slice(index + 1)))
            }
            else {
                var wordList = PHTWords.GetWordMatches(getCryptogramPatterns(encryptedWords[index]), null, PHTWords.GetCryptoIdx(encryptedWords[index]), null, null, getDictionaries(), getMinFrequency(), 10, 0, 0);

                var cypher = encryptedWords[index];
                var mapTry = "";
                for (var w = 0; w < wordList.length; w++) {
                    var word = wordList[w].value;
                    for (var i = 0; i < word.length; i++) {
                        for (var j = 0; j < gMapping.length; j++) {
                            if (cypher[i] == gMapping[j].cypher) {
                                if (!gMapping[j].locked) {
                                    mapTry += gMapping[j].cypher;
                                    gMapping[j].key = word[i];
                                    gMapping[j].locked = true;
                                }
                            }
                        }
                    }

                    if (doSolveCryptogram(encryptedWords.slice(0, index).concat(encryptedWords.slice(index + 1)), counts.slice(0, index).concat(counts.slice(index + 1)))) {
                        return true;
                    }

                    if (mapTry) {
                        for (var j = 0; j < gMapping.length; j++) {
                            if (mapTry.indexOf(gMapping[j].cypher) > -1) {
                                gMapping[j].locked = false;
                            }
                        }
                        mapTry = "";
                    }
                }
            }

            return false;
        }


        /**
         *
         */
        function doSolveCryptoAnagram(encryptedWords, decryptedWords, map) {

            // base case to exit and display possible solution
            if (encryptedWords.length == decryptedWords.length) {
                var lockCount = 0;
                for (var i = 0; i < gMapping.length; i++) {
                    if (gMapping[i].locked) {
                        lockCount++;
                    }
                }

                if ((lockCount / gMapping.length) > 0.75) {
                    return true;
                }
                else {
                    return false;
                }
            }

            // find the best encrypted word to try next and move it to the front of the list.
            var index = decryptedWords.length;
            var encryptedWord = encryptedWords[index];
            var wordList = PHTWords.GetWordMatches(null, getCryptoAnagramPatterns(encryptedWord), null, PHTWords.GetCryptoAnagramIdx(encryptedWord), null, getDictionaries(), getMinFrequency(), 10, 0, 0);
            for (var i = index + 1; i < encryptedWords.length; i++) {
                if (wordList.length < 2) {
                    break;
                }

                encryptedWord = encryptedWords[i];
                var words = PHTWords.GetWordMatches(null, getCryptoAnagramPatterns(encryptedWord), null, PHTWords.GetCryptoAnagramIdx(encryptedWord), null, getDictionaries(), getMinFrequency(), 10, 0, 0);
                if (words.length < wordList.length) {
                    index = i;
                    wordList = words;
                }
            }

            encryptedWords = encryptedWords.slice(0, decryptedWords.length).concat(encryptedWords.slice(index, index + 1)).concat(encryptedWords.slice(decryptedWords.length, index)).concat(encryptedWords.slice(index + 1));


            // get possible words for selected index and apply the pattern and recurse.            

            wordList.push(new WordInfo("", 0)); // just in case we do not know about this word.

            var encryptFreq = getFrequencyCharMap(encryptedWord);

            for (var j = 0; j < wordList.length; j++) {
                var mapTry = "";
                var newMap = map;

                if (wordList[j].value != "") {
                    // Calculate latest mapping with this word.
                    newMap = mergeFrequencyMaps(map, encryptFreq, getFrequencyCharMap(wordList[j].value));

                    // make sure that the new map is valid and has no values with no possible mappings or duplicate mappings
                    var keys = Object.keys(newMap);
                    var values = [];
                    var validMap = true;
                    for (var k = 0; k < keys.length; k++) {
                        if (newMap[keys[k]].length == 0) {
                            validMap = false;
                            break;
                        }
                        else if (newMap[keys[k]].length == 1) {
                            if (values.indexOf(newMap[keys[k]]) > -1) {
                                validMap = false;
                                break;
                            }
                            else {
                                values.push(newMap[keys[k]]);
                            }
                        }
                    }
                    if (!validMap) {
                        break;
                    }

                    // apply the latest character possibilities to the global crypto map
                    for (var k = 0; k < gMapping.length; k++) {
                        if (!gMapping[k].locked) {
                            if (newMap[gMapping[k].cypher] && (newMap[gMapping[k].cypher].length == 1)) {
                                mapTry += gMapping[k].cypher;
                                gMapping[k].key = newMap[gMapping[k].cypher];
                                gMapping[k].locked = true;
                            }
                        }
                    }
                }

                decryptedWords.push(wordList[j].value)
                if (doSolveCryptoAnagram(encryptedWords, decryptedWords, newMap)) {
                    return true;
                }
                decryptedWords.pop();

                // Undo any mappings applied from this word if any were applied.
                if (mapTry) {
                    for (var k = 0; k < gMapping.length; k++) {
                        if (mapTry.indexOf(gMapping[k].cypher) > -1) {
                            gMapping[k].locked = false;
                        }
                    }
                }
            }

            return false;
        }

        /**
         * Return a new map object that is merged with the possible mappings defined by the encryptFreq and decryptFreq lists.
         */
        function mergeFrequencyMaps(map, encryptFreq, decryptFreq) {
            var result = {};

            // clone existing map.
            var keys = Object.keys(map);
            for (var i = 0; i < keys.length; i++) {
                result[keys[i]] = map[keys[i]];
            }

            // merge the possible values for each encrypted letter into the existing map
            for (var i = 0; i < encryptFreq.length; i++) {
                if (encryptFreq[i]) {
                    for (var j = 0; j < encryptFreq[i].length; j++) {
                        var cypher = encryptFreq[i][j];
                        if (result[cypher]) {
                            var possibles = "";
                            for (var k = 0 ; k < result[cypher].length; k++) {
                                if (decryptFreq[i].indexOf(result[cypher].charAt(k)) > -1) {
                                    possibles += result[cypher].charAt(k);
                                }
                            }
                            result[cypher] = possibles;
                        }
                        else {
                            result[cypher] = decryptFreq[i];
                        }
                    }
                }
            }

            // reduce mappings by removing a single mapping from any existing mapping.
            keys = Object.keys(result);
            for (var i = 0; i < keys.length; i++) {
                if (result[keys[i]].length == 1) {
                    for (var j = 0; j < keys.length; j++) {
                        if ((result[keys[j]].length > 1) && (result[keys[j]].indexOf(result[keys[i]]) > -1)) {
                            result[keys[j]] = result[keys[j]].replace(result[keys[i]], "");
                            if (result[keys[j]].length == 1) {
                                i = -1;
                            }
                        }
                    }
                }
            }

            return result;
        }

        /**
         * Return an array of characters that have a unique frequency in the specified word.
         */
        function getUniqueFrequencyChars(word) {
            var result = [];

            var map = getFrequencyCharMap(word);

            for (var i = 0; i < map.length; i++) {
                if (map[i] && (map[i].length == 1)) {
                    result.push(map[i]);
                }
            }

            return result;
        }

        /**
         * Returns an array of strings where the array index equals the number of times the characters in the string
         * occur in the word.
         */
        function getFrequencyCharMap(word) {
            var result = [];

            if (word) {
                var letterCounts = getCharFrequencyMap(word);

                var keys = Object.keys(letterCounts);
                for (var i = 0; i < keys.length; i++) {
                    if (result[letterCounts[keys[i]]]) {
                        result[letterCounts[keys[i]]] += keys[i];
                    }
                    else {
                        result[letterCounts[keys[i]]] = keys[i];
                    }
                }
            }

            return result;
        }

        /**
         * Return an object who's keys are characters and values are the number of times that character appears in the word.
         */
        function getCharFrequencyMap(word) {
            var result = {};

            if (word) {
                for (var i = 0; i < word.length; i++) {
                    if (result[word.charAt(i)]) {
                        result[word.charAt(i)]++;
                    }
                    else {
                        result[word.charAt(i)] = 1;
                    }
                }
            }

            return result;
        }


        /**
         *
         */
        function doWordClick(encryptedText) {
            encryptedText = PHTWords.Trim(encryptedText, getExcludeText());

            if (encryptedText) {
                renderSearchResults([]);

                gSearchMapTry = "";
                gSearchCypher = encryptedText;

                if (getCryptoAnagram()) {
                    PHTWords.GetWordMatches(null, getCryptoAnagramPatterns(encryptedText), null, PHTWords.GetCryptoAnagramIdx(encryptedText), null, getDictionaries(), 0, getMaxResults(), 0, 0, renderSearchResults, new Date().getTime());
                }
                else {
                    PHTWords.GetWordMatches(getCryptogramPatterns(encryptedText), null, PHTWords.GetCryptoIdx(encryptedText), null, null, getDictionaries(), 0, getMaxResults(), 0, 0, renderSearchResults, new Date().getTime());
                }
            }
        }

        /**
         * Return a string that contains pattern list to use as word patterns for a call to PHTWords.GetWordMatches to limit the number
         * of results returned to those allowed by the mapping.
         */
        function getCryptogramPatterns(encryptedText) {
            var pattern = "";

            var wildCard = "_";

            var mappedCharacter = getExcludeText().trim();
            for (var i = 0; i < gMapping.length; i++) {
                if (gMapping[i].locked) {
                    mappedCharacter = mappedCharacter + gMapping[i].key;
                }
            }

            if (mappedCharacter) {
                wildCard = "[^" + PHTWords.EscapeString(mappedCharacter) + "]";
            }

            for (var i = 0; i < encryptedText.length; i++) {
                var found = false;
                for (var j = 0; j < gMapping.length; j++) {
                    if (encryptedText[i] == gMapping[j].cypher) {
                        if (gMapping[j].locked) {
                            pattern = pattern + PHTWords.EscapeString(gMapping[j].key);
                        } else {
                            pattern = pattern + wildCard;
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    pattern = pattern + PHTWords.EscapeString(encryptedText[i]);
                }
            }

            return pattern;
        }

        /**
         * Return a string that contains pattern list to use as anagram patterns for a call to PHTWords.GetWordMatches to limit the number
         * of results returned to those allowed by the mapping.
         */
        function getCryptoAnagramPatterns(encryptedText) {
            var result = "";

            var map = getCharFrequencyMap(encryptedText);

            for (var i = 0; i < gMapping.length; i++) {
                if (gMapping[i].locked) {
                    var cypher = gMapping[i].cypher;
                    var pattern = gMapping[i].key;
                    if (map[cypher]) {
                        for (var j = 1; j < map[cypher]; j++) {
                            pattern += pattern.charAt(0);
                        }

                        if (result) {
                            result += "&";
                        }
                        result += "%" + pattern + "%&!%" + pattern + pattern[0] + "%";
                    }
                    else {
                        if (result) {
                            result += "&";
                        }
                        result += "!%" + pattern + "%";
                    }
                }
            }

            return result;
        }

    </script>
</head>
<body onload="doEncryptionChanged();">

    <table style="width:100%;">
        <tr>
            <td id="SubstitutionMapping" style="vertical-align:top;white-space:nowrap;">
                <span>Count:</span>
                <input type="text" size="5" disabled="disabled" id="MapCount" />
                <label><input type="checkbox" id="AutoApply" checked="checked" value="1" onchange="doEncryptionChanged();" />Auto Apply</label>
                <br />
                <hr />
                <div id="MappingTableAdvisory" style="text-align: center;color:red;"></div>
                <table id="MappingTable">
                </table>
            </td>
            <td style="vertical-align:top;border-right: 3px solid black;border-left: 3px solid black;padding-left:5px; padding-right:10px;">
                
                <table style="width:100%">
                    <tr>
                        <td style="white-space:nowrap;">
                            <span>Exclude:</span>
                            <input type="text" id="Exclude" onkeyup="doEncryptionChanged();" value="+-=\/_"/>
                            <label><input type="checkbox" id="Numbers" checked="checked" value="Numbers" onchange="doEncryptionChanged();" />Numbers</label>
                            <label><input type="checkbox" id="Punctuation" checked="checked" value="Punctuation" onchange="doEncryptionChanged();" />Punctuation</label>
                            <label><input type="checkbox" id="Whitespace" checked="checked" value="Whitespace" onchange="doEncryptionChanged();" />Whitespace</label>
                            <br />
                            <hr />
                        </td>
                    </tr>
                </table>

                <table id="AutoMapping" style="width:100%">
                    <tr>
                        <td colspan="2">English Frequency:</td>
                    </tr>
                    <tr>
                        <td id="OccuranceFreqTitle" style="text-align:right;">
                            Occurance:
                        </td>
                        <td style="white-space:nowrap;">
                            <input type="text" id="OccuranceFreq" value="ETAONRISHDLFCMUGYPWBVKJXQZ" size="50" />
                            <button onclick="doApplyOccurancyFreq()">Apply</button>
                        </td>
                    </tr>
                    <tr>
                        <td id="FirstFreqTitle" style="text-align:right;">
                            First Letter:
                        </td>
                        <td style="white-space:nowrap;">
                            <input type="text" id="FirstFreq" value="TASHWIOBMFCLDPNEGRYUVJKQZX" size="50" />
                            <button onclick="doApplyFirstFreq()">Apply</button>
                        </td>
                    </tr>
                    <tr>
                        <td id="DoubleFreqTitle" style="text-align:right;">
                        Double:
                        </td>
                        <td style="white-space:nowrap;">
                            <input type="text" id="DoubleFreq" value="LESOTFRNPC" size="50" />
                            <button onclick="doApplyDoubleFreq()">Apply</button>
                        </td>
                    </tr>
                    <tr>
                        <td id="RotateN" style="text-align:right;">
                        Rotate:
                        </td>
                        <td style="white-space:nowrap;">
                            <input type="number" id="RotateValue" value="13" size="50" />
                            <button onclick="doApplyRotateN()">Apply</button>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="2"><hr /></td>
                    </tr>
                </table>

                <span>Decrypted:</span>
                <button onclick="doSolve()" style="float:right;">Solve</button>
                <pre id="Decrypted" style="width:100%;height:250px;overflow-y:scroll;font-family:Courier New, Courier, monospace;font-size:12px;border: 1px solid black;padding:2px;"></pre>
                <span>Encrypted:</span>
                <label><input id="IgnoreCase" type="checkbox" checked="checked" value="1" onchange="doEncryptionChanged();" />Ignore Case</label>
                <label style="float:right;"><input id="CryptoAnagram" type="checkbox" value="1" onchange="doEncryptionChanged();"/>Crypto Anagram</label>
                <textarea id="Encrypted" style="width:100%;height:250px;font-family:Courier New, Courier, monospace;font-size:12px;" onkeyup="doEncryptionChanged();"></textarea>

            </td>
            <td style="vertical-align:top;">
                <span>Dictionary:</span>
                <label><input type="checkbox" id="WordList" checked="checked" value="0" />Word&nbsp;List</label>
                <label><input type="checkbox" id="ModernEnglish" checked="checked" value="1" />Modern&nbsp;English</label>
                <label><input type="checkbox" id="MiddleEnglish" value="2" />Middle&nbsp;English</label>
                <hr />
                <table style="width:100%;">
                    <tr>
                        <td colspan="2">
                            <label>Min Frequency: <input type="text" id="MinFrequency" size="10" value="1" title="Modern English (BNC):
  0 = 700,000 words
  1 = 80,000 words
  15 = 60,000 words
  50 = 40,000 words
  200 = 20,000 words
  500 = 10,000 words
  1500 = 5,000 words
  4000 = 2,500 words
  10000 = 1,000 words
" /></label>
                            <label>Max Results: <input type="text" maxlength="4" id="MaxResults" size="5" value="200" /></label>
                        </td>
                    </tr>
                </table>
                <hr />
                <label>Results: <input type="text" size="5" disabled="disabled" id="ResultsCount" /></label>
                <label>Duration: <input type="text" size="12" disabled="disabled" id="Duration" /></label>
                <br />
                <hr />
                <table id="Table1" style="width:100%;">
                    <tr>
                        <th style="text-align:left;"><a href="javascript:void(0)" onclick="doSortByWords();">Words</a></th>
                        <th style="text-align:right;"><a href="javascript:void(0)" onclick="doSortByFrequency();">Frequency</a></th>
                    </tr>
                </table>
                <div style="height:525px;overflow-y:auto;border:1px solid black;">
                    <table id="ResultsTable" style="width:100%;">
                    </table>
                </div>
               <br />
                <span style="font-weight:bold;">Word List:</span>
                <label><input type="checkbox" id="LinesAsWords" onclick="doGetWordList();" value="1" />Lines Are Words</label>
                <label><input type="checkbox" id="UseFrequency" onclick="doGetWordList();" value="1" />Use BNC Frequency</label>
                <textarea id="WordListText" style="width:100%;height:250px;font-family:Courier New, Courier, monospace;font-size:12px;" onchange="doGetWordList();"></textarea>
             </td>
        </tr>
    </table>

</body>
</html>
