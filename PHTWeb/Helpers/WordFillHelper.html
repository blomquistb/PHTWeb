<!DOCTYPE html>

<!--
Featue Todo:


-->

<html xmlns="http://www.w3.org/1999/xhtml">
<head id="Head1" runat="server">
    <title>Word Search Helper</title>

    <script src="/es6-shim.js"></script>
    <script src="/jquery-2.1.4.js"></script>
    <script src="/Utils.js"></script>    
    <script src="/PHTWords.js"></script>


    <style type="text/css">
        table.GridTable {
            text-align: center;
            vertical-align: central;
        }

        table.GridTable td {
            border: 1px solid black;
            margin: 0px;
            width: 1.5em;
            height: 1.5em;
            background-repeat: no-repeat;
        }
    </style>

    <script type="text/javascript">

        var gSolutions = [];
        var gSelected = [];

        var gSpaceToken = '_';
        var gSeperatorToken = '#';
        var gRequiredToken = '!';


        function getLooseFit() {
            var elem = document.getElementById("LooseFit");
            if (elem) {
                return elem.checked;
            }

            return false;
        }

        ///
        /// Grid object definition.
        ///
        function Grid(grid) {
            this.width = 0;
            this.height = 0;
            this.rows = [];

            this.across = [];
            this.down = [];

            if (typeof (grid == "string")) {
                var text = grid.trim().replace("\r", "");
                var lines = text.split("\n");

                for (var row = 0; row < lines.length; row++) {
                    var letters = lines[row].split("");
                    var cells = [];

                    for (var j = 0; j < letters.length; j++) {
                        if (letters[j] == gSeperatorToken) {
                            cells.push(new GridCell("", false, true));
                        }
                        else if (letters[j] == gRequiredToken) {
                            cells.push(new GridCell("", true, false));
                        }
                        else if (letters[j] == gSpaceToken) {
                            cells.push(new GridCell("", !getLooseFit(), false));
                        }
                        else {
                            cells.push(new GridCell(letters[j], true, false));
                        }
                    }

                    this.rows.push(cells);

                    // set the grid width to the width of the widest row.
                    if (cells.length > this.width) {
                        this.width = cells.length;
                    }
                }

                this.height = this.rows.length;

                // Clean up the row lengths if needed.
                //
                for (var row = 0; row < this.height; row++) {
                    if (this.rows[row].length != this.width) {
                        for (var i = this.width - this.rows[row].length; i >= 0; i--) {
                            this.rows[row].push(new GridCell("", false, true));
                        }
                    }
                }

                // Calculate the positions for word placements.
                var positionIdex = 1;

                for (var r = 0; r < this.height; r++) {
                    for (var c = 0; c < this.width; c++) {
                        if (this.IsValid(r, c) && !this.IsValid(r, c - 1) && this.IsValid(r, c + 1)) {
                            var length = 2;
                            for (var i = c+2; this.IsValid(r, c + i) ; i++) {
                                length++;
                            }
                            this.across.push(new Position(positionIdex, 'A', length));
                        }
                    }
                }


            }
        }

        //
        Grid.prototype.IsValid = function (row, col) {
            return row >= 0 && col >= 0 && row < this.height && col < this.width && !this.rows[row][col].seperator;
        }

        ///
        /// GridCell object declaration
        ///
        function GridCell(value, required, seperator) {
            this.value = value;
            this.required = required;
            this.seperator = seperator;
        }

        ///
        /// Positions object declaration
        ///
        function Position(number, direction, length) {
            this.number = number;
            this.direction = direction;
            this.length = length;
        }

        //
        //
        //
        function renderGrid() {
            var grid = getGrid();

            var dimensions = document.getElementById("GridDimensions");
            if (dimensions) {
                dimensions.innerText = grid.width + " x " + grid.height;
            }


            var table = document.getElementById("GridTable");
            if (table) {
                table.innerHTML = "";
                for (var row = 0; row < grid.height; row++) {
                    var r = table.insertRow(-1);
                    for (var col = 0; col < grid.width; col++) {
                        var c = r.insertCell(-1);
                        c.innerHTML = grid.rows[row][col].value;

                        if (getLooseFit() && grid.rows[row][col].required) {
                            c.style.backgroundColor = "lightgray";
                        }

                        if (grid.rows[row][col].seperator) {
                            c.style.backgroundColor = "black";
                        }
                    }
                }
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////

        function doSearch() {
            var countElem = document.getElementById("ResultsCount");
            if (countElem) {
                countElem.value = "";
            }

            var durElem = document.getElementById("Duration");
            if (durElem) {
                durElem.value = "";
            }

            // If the Auto Clear checkbox is checked then clear any non selected results.
            //
            if (getAutoClear()) {
                doClearSolutions(true);
            }

            window.setTimeout("doSearchWork();", 0);
        }

        function doSearchWork() {
            var startTime = new Date().getTime();

            var newSolutions = [];

            switch (getSearchType()) {
                case 1: // Normal Word Search
                    {
                        var start = getStart();
                        var grid = getGrid(!getAllowOverlap());
                        newSolutions = grid.FindWordSearchSolutions(start.row, start.col, getSearchBackwards(), getWordBreaks(), getHasSpaces(), getMinWordLength(), getMaxWordLength(), getDictionaries(), getMinFrequency());
                        break;
                    }
                case 2: // Word Snake Search
                    {
                        var start = getStart();
                        var grid = getGrid(!getAllowOverlap());
                        newSolutions = grid.FindWordSnakeSolutions(start.row, start.col, getSearchBackwards(), getWordBreaks(), getHasSpaces(), getMinWordLength(), getMaxWordLength(), getDictionaries(), getMinFrequency());
                        break;
                    }
                case 3: // Knights Move Search
                    {
                        var start = getStart();
                        var grid = getGrid(!getAllowOverlap());
                        newSolutions = grid.FindKnightsPathSolutions(start.row, start.col, getSearchBackwards(), getWordBreaks(), getHasSpaces(), getMinWordLength(), getMaxWordLength(), getDictionaries(), getMinFrequency());
                        break;
                    }
                case 4: // Boggle Search
                    {
                        var start = getStart();
                        var grid = getGrid(!getAllowOverlap());
                        newSolutions = grid.FindBoggleSolutions(start.row, start.col, getSearchBackwards(), getWordBreaks(), getHasSpaces(), getMinWordLength(), getMaxWordLength(), getDictionaries(), getMinFrequency());
                        break;
                    }
                case 5: // Letter Skip Search
                    {
                        var start = getStart();
                        var grid = getGrid(!getAllowOverlap());
                        newSolutions = grid.FindLtrSkipSolutions(start.row, start.col, getSearchBackwards(), getWordBreaks(), getHasSpaces(), getMinWordLength(), getMaxWordLength(), getDictionaries(), getMinFrequency());
                        break;
                    }
            }

            // Merge soloutions into results table.
            //
            for (var i = 0; i < newSolutions.length; i++) {
                var j = 0;
                for (j = 0; j < gSolutions.length; j++) {
                    if (CompareGridSolutionPaths(newSolutions[i], gSolutions[j]) == 0) {
                        break;
                    }
                }

                if (j == gSolutions.length) {
                    gSolutions.push(newSolutions[i]);
                }
            }

            gSolutions.sort(function (a, b) { return -CompareGridSolutionFrequency(a, b) });

            renderSolutions();

            setDuration(new Date().getTime() - startTime);

            beep();
        }

        function doUpdateGridText() {
            var elem = document.getElementById("RequiredToken");
            if (elem) {
                gRequiredToken = elem.value;
            }

            elem = document.getElementById("SpaceToken");
            if (elem) {
                gSpaceToken = elem.value;
            }

            elem = document.getElementById("SeperatorToken");
            if (elem) {
                gSeperatorToken = elem.value;
            }

            var grid = getGrid();
            var hasSpaces = false;

            for (var row = 0; !hasSpaces && row < grid.height; row++) {
                for (var col = 0; !hasSpaces && col < grid.width; col++) {
                    if (grid.rows[row][col].value == ' ') {
                        hasSpaces = true;
                    }
                }
            }

            setHasSpaces(hasSpaces);

            renderGrid();
        }

        function doGetWordList() {
            PHTWords.Clear();

            var LinesAsWords = false;

            var elem = document.getElementById("LinesAsWords");
            if (elem && elem.checked) {
                LinesAsWords = true;
            }

            elem = document.getElementById("WordListText");
            if (elem) {
                var text = elem.value.trim();
                var lines = text.split("\n");

                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim().replace(/[\s]+/g, ' ');

                    var words = line.split(" ");
                    for (var j = 0; j < words.length; j++) {
                        PHTWords.AddWord(words[j], 7000000);
                    }

                    if (LinesAsWords && (words.length > 1)) {
                        PHTWords.AddWord(line, 7000100);
                    }
                }
            }
        }

        function doClearSolutions(keepSelected) {
            gSolutions = [];

            if (keepSelected) {
                gSolutions = gSolutions.concat(gSelected);
            }
            else {
                gSelected = [];
            }

            var countElem = document.getElementById("ResultsCount");
            if (countElem) {
                countElem.value = "";
            }

            var durElem = document.getElementById("Duration");
            if (durElem) {
                durElem.value = "";
            }

            renderSolutions();
            renderGrid();
        }

        function doSortByFrequency() {
            gSolutions.sort(function (a, b) { return -CompareGridSolutionFrequency(a, b) });

            renderSolutions();
        }

        function doSortByWords() {
            gSolutions.sort(function (a, b) { return CompareGridSolutionWords(a, b) });
            renderSolutions();
        }

        function doSortByLength() {
            gSolutions.sort(function (a, b) { return -CompareGridSolutionLengths(a, b) });
            renderSolutions();
        }

        function doSelect(index) {

            var i = 0;
            for (i = 0; i < gSelected.length; i++) {
                if (CompareGridSolutionPaths(gSelected[i], gSolutions[index]) == 0) {
                    gSelected.remove(i);
                }
            }

            if (i == gSelected.length) {
                gSelected.push(gSolutions[index]);
            }

            renderSolutions();
            renderGrid();
        }

        function getGrid() {
            var grid = null;

            var elem = document.getElementById("GridText");
            if (elem) {
                grid = new Grid(elem.value);
            }

            return grid;
        }

        function hideElement(elem) {
            if (elem) {
                elem.style.display = "none";
            }
        }

        function showElement(elem) {
            if (elem) {
                elem.style.display = "";
            }
        }

        function setSearchType(type) {
            hWrapElem = document.getElementById("HorizontalWrapLabel");
            vWrapElem = document.getElementById("VerticalWrapLabel");
            hSearchElem = document.getElementById("HorizontalSearchLabel");
            vSearchElem = document.getElementById("VerticalSearchLabel");

            hideElement(hWrapElem);
            hideElement(vWrapElem);
            hideElement(hSearchElem);
            hideElement(vSearchElem);

            switch (type) {
                case 1: { // Word Search
                    setAllowOverlap(true);
                    break;
                }
                case 2: { // Snake Search
                    setAllowOverlap(false);
                    showElement(hWrapElem);
                    showElement(vWrapElem);
                    break;
                }
                case 3: { // KnightSearch
                    setAllowOverlap(false);
                    break;
                }
                case 4: { // BoggleSearch
                    setAllowOverlap(false);
                    break;
                }
                case 5: { // LtrSkipSearch
                    setAllowOverlap(true);
                    showElement(hSearchElem);
                    showElement(vSearchElem);
                    break;
                }
            }
        }

        function getSearchType() {
            var result = 1; // Normal Word Search

            var elem = document.getElementById("SnakeSearch");
            if (elem && elem.checked) {
                result = 2;
            }

            elem = document.getElementById("KnightSearch");
            if (elem && elem.checked) {
                result = 3;
            }

            elem = document.getElementById("BoggleSearch");
            if (elem && elem.checked) {
                result = 4;
            }

            elem = document.getElementById("LtrSkipSearch");
            if (elem && elem.checked) {
                result = 5;
            }

            return result;
        }

        function getAllowOverlap() {
            result = getSearchType() == 1;
            var elem = document.getElementById("AllowOverlap");
            if (elem) {
                result = elem.checked;
            }

            return result;
        }

        function setAllowOverlap(allowOverlap) {
            var elem = document.getElementById("AllowOverlap");
            if (elem) {
                elem.checked = allowOverlap;
            }
        }

        function getSearchBackwards() {
            var result = false;

            var elem = document.getElementById("End");
            if (elem) {
                result = elem.checked;
            }

            return result;
        }

        function getStart() {
            var results = new GridPosition(-1, -1);

            var elem = document.getElementById("StartCell");
            if (elem) {
                var text = elem.value.trim();
                var breakText = text.split(',');
                if (breakText.length == 2) {
                    results.row = parseInt(breakText[0].trim(), 10);
                    if (isNaN(results.row)) results.row = -1;

                    results.col = parseInt(breakText[1].trim(), 10);
                    if (isNaN(results.col)) results.col = -1;
                }
            }

            return results;
        }

        function setStart(row, col) {
            var elem = document.getElementById("StartCell");
            if (elem) {
                elem.value = row + ',' + col;
            }

            renderGrid();
        }

        function setHasSpaces(enabled) {
            var elem = document.getElementById("HasSpaces");
            if (elem) {
                elem.checked = enabled;
            }
        }

        function getHasSpaces() {
            var result = false;
            var elem = document.getElementById("HasSpaces");
            if (elem) {
                result = elem.checked;
            }

            return result;
        }

        function getWordBreaks() {
            var results = [];

            var elem = document.getElementById("WordBreaks");
            if (elem) {
                var text = elem.value.trim();
                var breakText = text.split(',');
                for (var i = 0; i < breakText.length; i++) {
                    var value = parseInt(breakText[i].trim(), 10);
                    if (isNaN(value)) {
                        value = 0;
                    }
                    if (value < 0) {
                        value = -value;
                    }
                    results.push(value);
                }
            }

            return results;
        }

        function getMinWordLength() {
            var result = 0;

            var elem = document.getElementById("MinWordLength");
            if (elem) {
                result = parseInt(elem.value.trim());
                if (isNaN(result)) result = 0;
            }

            return result;
        }

        function getMaxWordLength() {
            var result = 0;

            var elem = document.getElementById("MaxWordLength");
            if (elem) {
                result = parseInt(elem.value.trim());
                if (isNaN(result)) result = 0;
            }

            return result;
        }

        function getHorizontalWrap() {
            var elem = document.getElementById("HorizontalWrap");
            if (elem) {
                return elem.checked;
            }

            return false;
        }

        function getVerticalWrap() {
            var elem = document.getElementById("VerticalWrap");
            if (elem) {
                return elem.checked;
            }

            return false;
        }

        function getHorizontalSearch() {
            var elem = document.getElementById("HorizontalSearch");
            if (elem) {
                return elem.checked;
            }

            return false;
        }

        function getVerticalSearch() {
            var elem = document.getElementById("VerticalSearch");
            if (elem) {
                return elem.checked;
            }

            return false;
        }

        function getAutoClear() {
            var elem = document.getElementById("AutoClear");
            if (elem) {
                return elem.checked;
            }

            return false;
        }



        function getRemainingTextFlag() {
            var result = "None";

            var elem = document.getElementById("String");
            if (elem && elem.checked) {
                result = "String";
            }

            elem = document.getElementById("Grid");
            if (elem && elem.checked) {
                result = "Grid";
            }

            return result;
        }






        function getDictionaries() {
            var dictionaries = "";

            var elem = document.getElementById("WordList");
            if (elem && elem.checked) {
                dictionaries += "0";
            }

            elem = document.getElementById("ModernEnglish");
            if (elem && elem.checked) {
                dictionaries += "1";
            }

            elem = document.getElementById("MiddleEnglish");
            if (elem && elem.checked) {
                dictionaries += "2";
            }

            return dictionaries
        }

        function getMinFrequency() {
            var result = 0;

            var elem = document.getElementById("MinFrequency");
            if (elem) {
                result = parseInt(elem.value.trim());
                if (isNaN(result)) result = 0;
            }

            return result;
        }

        function setDuration(duration) {
            var millis = (duration % 1000);
            var seconds = Math.floor((duration / 1000)) % 60;
            var minutes = Math.floor((duration / 1000) / 60);

            var text = ""
            if (minutes < 10) text += "0";
            text += minutes;
            text += ":";
            if (seconds < 10) text += "0";
            text += seconds;
            text += ":";
            if (millis < 10) {
                text += "00";
            } else if (millis < 100) {
                text += "0";
            }
            text += millis;

            var elem = document.getElementById("Duration");
            if (elem) {
                elem.value = text;
            }
        }


        function isGridCellSelected(row, col) {
            for (var i = 0; i < gSelected.length; i++) {
                for (var j = 0; j < gSelected[i].grid.positions.length; j++) {
                    if ((row == gSelected[i].grid.positions[j].row) && (col == gSelected[i].grid.positions[j].col)) {
                        return true;
                    }
                }
            }

            return false;
        }

        function getGridCellSelectionCount(row, col) {
            var result = 0;
            for (var i = 0; i < gSelected.length; i++) {
                for (var j = 0; j < gSelected[i].grid.positions.length; j++) {
                    if ((row == gSelected[i].grid.positions[j].row) && (col == gSelected[i].grid.positions[j].col)) {
                        result++;
                    }
                }
            }

            return result;
        }

        function renderSolutions() {

            var duplicates = 0;

            var table = document.getElementById("ResultsTable");
            if (table) {
                table.innerHTML = "";
                for (var i = 0; i < gSolutions.length; i++) {

                    if ((i != 0) && (gSolutions[i].word.value == gSolutions[i - 1].word.value)) {
                        duplicates++;
                    }
                    else {
                        var r = table.insertRow(-1);
                        var c = r.insertCell(-1);
                        c.innerHTML = "<b>" + gSolutions[i].word.value + "</b>"
                        c = r.insertCell(-1);
                        c.style.textAlign = "right";
                        c.innerHTML = "(" + Math.floor(gSolutions[i].word.frequency) + ")";
                    }

                    var r = table.insertRow(-1);
                    var c = r.insertCell(-1);
                    c.style.fontSize = "smaller";
                    c.colSpan = 2;
                    var html = "";
                    for (var j = 0; j < gSolutions[i].grid.positions.length; j++) {
                        html += "(" + gSolutions[i].grid.positions[j].row + "," + gSolutions[i].grid.positions[j].col + ")";
                    }
                    c.innerHTML = html;

                    c.setAttribute("onclick", "doSelect(" + i + ");");

                    for (var j = 0; j < gSelected.length; j++) {
                        if (CompareGridSolutionPaths(gSelected[j], gSolutions[i]) == 0) {
                            c.style.backgroundColor = "yellow";
                            break;
                        }
                    }
                }
            }

            var elem = document.getElementById("ResultsCount");
            if (elem) {
                elem.value = "" + (gSolutions.length - duplicates) + " (" + gSolutions.length + ")";
            }
        }


        ///
        /// Grid object definition.
        ///


        Grid.prototype.ContinueSearching = function (row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            if (maxWordLength && (text.length >= maxWordLength)) {
                return false;
            }

            var pattern = PHTWords.EscapeString(text);

            if (searchBackwards) {
                pattern = "%_" + pattern;
            }
            else {
                pattern = pattern + "_%";
            }

            if (PHTWords.GetWordMatches(pattern, null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength) == 0) {
                return false;
            }

            return true;
        }

        Grid.prototype.FindWordSearchSolutions = function (row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (wordLengths && wordLengths[0]) {
                minWordLength = wordLengths[0];
                maxWordLength = wordLengths[0];
            }

            if ((row >= 0) && (col >= 0)) {
                solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, +0, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, +0, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
            }
            else {
                for (var row = 0; row < this.height; row++) {
                    for (var col = 0; col < this.width; col++) {
                        if (!this.rows[row][col].visited) {
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, +0, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, -1, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, +0, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            solutions = solutions.concat(this.FindWordSearchWords(row, col, +1, -1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        }
                    }
                }
            }

            return solutions;
        }

        Grid.prototype.FindWordSearchWords = function (row, col, rowAdj, colAdj, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];
            var text = "";
            var path = [];

            while (this.IsValid(row, col)) {
                path.push(new GridPosition(row, col));

                if (searchBackwards) {
                    text = this.rows[row][col].value + text;
                }
                else {
                    text = text + this.rows[row][col].value;
                }

                if (maxWordLength && (text.length > maxWordLength)) {
                    break;
                }

                if (text.length >= minWordLength) {
                    var words = PHTWords.GetWordMatches(PHTWords.EscapeString(text), null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength);
                    if (words.length == 1) {
                        var grid = new Grid(this);
                        grid.positions = grid.positions.concat(path);
                        solutions.push(new GridSolution(grid, words[0]));
                    }
                }

                if (!this.ContinueSearching(row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency)) {
                    break;
                }

                row += rowAdj;
                col += colAdj;
            }

            return solutions;
        }

        Grid.prototype.FindWordSnakeSolutions = function (row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if ((row < 0) && (col < 0)) {
                for (row = 0; row < this.height; row++) {
                    for (col = 0; col < this.width; col++) {
                        solutions = solutions.concat(this.FindWordSnakeSolutions(row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                    }
                }
            }
            else {
                var startIndex = 0;
                var endIndex = wordLengths.length;
                var indexAdj = 1;
                var index = startIndex;

                if (searchBackwards) {
                    startIndex = wordLengths.length - 1;
                    endIndex = 0;
                    indexAdj = -1
                    index = startIndex;
                }

                for (var i = 0; i < wordLengths.length; i++) {
                    if ((wordLengths.length > 1) || wordLengths[index] != 0) {
                        minWordLength = wordLengths[index];
                        maxWordLength = wordLengths[index];
                    }

                    if (index == startIndex) {
                        solutions = this.FindWordSnakeWords(row, col, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency);
                    }
                    else {

                        if (hasSpaces) {
                            // Find solutions based on each of the previous solutions where a space exists after the word.
                            //
                            var newSolutions = [];

                            for (var j = 0; j < solutions.length; j++) {
                                var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                                var row = lastCell.row;
                                var col = lastCell.col;

                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row, col + 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row, col - 1));
                            }

                            solutions = newSolutions;
                        }

                        var newSolutions = [];
                        for (var j = 0; j < solutions.length; j++) {
                            // Find solutions based on each of the previous solutions words that have been found.
                            //
                            var tempSolutions = [];
                            var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                            var row = lastCell.row;
                            var col = lastCell.col;

                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindWordSnakeWords(row + 1, col, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindWordSnakeWords(row - 1, col, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindWordSnakeWords(row, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindWordSnakeWords(row, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));

                            for (var k = 0; k < tempSolutions.length; k++) {
                                if (searchBackwards) {
                                    tempSolutions[k].word.value = tempSolutions[k].word.value + " " + solutions[j].word.value;
                                }
                                else {
                                    tempSolutions[k].word.value = solutions[j].word.value + " " + tempSolutions[k].word.value;
                                }
                                tempSolutions[k].word.frequency = (solutions[j].word.frequency + tempSolutions[k].word.frequency) / 2;
                            }

                            newSolutions = newSolutions.concat(tempSolutions);
                        }
                        solutions = newSolutions;
                    }

                    index = index + indexAdj;
                }
            }

            return solutions;
        }

        Grid.prototype.FindWordSnakeWords = function (row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (getHorizontalWrap()) {
                while (col < 0) {
                    col = col + this.width;
                }
                while (col >= this.width) {
                    col = col - this.width;
                }
            }

            if (getVerticalWrap()) {
                while (row < 0) {
                    row = row + this.height;
                }
                while (row >= this.height) {
                    row = row - this.height;
                }
            }

            if (!this.IsValid(row, col)) {
                return solutions;
            }

            if (searchBackwards) {
                text = this.rows[row][col].value + text;
            }
            else {
                text = text + this.rows[row][col].value;
            }

            if (maxWordLength && (text.length > maxWordLength)) {
                return solutions;
            }

            this.rows[row][col].visited = true;
            this.positions.push(new GridPosition(row, col));

            if (text.length >= minWordLength) {
                var words = PHTWords.GetWordMatches(PHTWords.EscapeString(text), null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength);
                if (words.length == 1) {
                    solutions.push(new GridSolution(new Grid(this), words[0]));
                }
            }

            if (this.ContinueSearching(row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency)) {
                solutions = solutions.concat(this.FindWordSnakeWords(row + 1, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSnakeWords(row - 1, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSnakeWords(row, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindWordSnakeWords(row, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
            }

            this.rows[row][col].visited = false;
            this.positions.pop();
            return solutions;
        }

        Grid.prototype.FindKnightsPathSolutions = function (row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            var startIndex = 0;
            var endIndex = wordLengths.length;
            var indexAdj = 1;
            var index = startIndex;

            if (searchBackwards) {
                startIndex = wordLengths.length - 1;
                endIndex = 0;
                indexAdj = -1
                index = startIndex;
            }

            for (var i = 0; i < wordLengths.length; i++) {
                if ((wordLengths.length > 1) || wordLengths[index] != 0) {
                    minWordLength = wordLengths[index];
                    maxWordLength = wordLengths[index];
                }

                if (index == startIndex) {
                    solutions = this.FindKnightsPathWords(row, col, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency);
                }
                else {
                    if (hasSpaces) {
                        var newSolutions = [];

                        for (var j = 0; j < solutions.length; j++) {
                            var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                            var row = lastCell.row;
                            var col = lastCell.col;

                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col - 2));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 2, col - 1));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 2, col + 1));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col + 2));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col + 2));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 2, col + 1));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 2, col - 1));
                            newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col - 2));
                        }

                        solutions = newSolutions;
                    }

                    var newSolutions = [];

                    for (var j = 0; j < solutions.length; j++) {
                        // Find solutions based on each of the previous solutions words that have been found.
                        //
                        var tempSolutions = [];
                        var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                        var row = lastCell.row;
                        var col = lastCell.col;

                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row + 1, col - 2, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row + 2, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row + 2, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row + 1, col + 2, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row - 1, col + 2, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row - 2, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row - 2, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        tempSolutions = tempSolutions.concat(solutions[j].grid.FindKnightsPathWords(row - 1, col - 2, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));

                        for (var k = 0; k < tempSolutions.length; k++) {
                            if (searchBackwards) {
                                tempSolutions[k].word.value = tempSolutions[k].word.value + " " + solutions[j].word.value;
                            }
                            else {
                                tempSolutions[k].word.value = solutions[j].word.value + " " + tempSolutions[k].word.value;
                            }
                            tempSolutions[k].word.frequency = (solutions[j].word.frequency + tempSolutions[k].word.frequency) / 2;
                        }

                        newSolutions = newSolutions.concat(tempSolutions);
                    }
                    solutions = newSolutions;
                }

                index = index + indexAdj;
            }

            return solutions;
        }

        Grid.prototype.FindKnightsPathWords = function (row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (!this.IsValid(row, col)) {
                return solutions;
            }

            if (searchBackwards) {
                text = this.rows[row][col].value + text;
            }
            else {
                text = text + this.rows[row][col].value;
            }

            if (maxWordLength && (text.length > maxWordLength)) {
                return solutions;
            }

            this.rows[row][col].visited = true;
            this.positions.push(new GridPosition(row, col));

            if (text.length >= minWordLength) {
                var words = PHTWords.GetWordMatches(PHTWords.EscapeString(text), null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength);
                if (words.length == 1) {
                    solutions.push(new GridSolution(new Grid(this), words[0]));
                }
            }

            if (this.ContinueSearching(row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency)) {
                solutions = solutions.concat(this.FindKnightsPathWords(row + 1, col - 2, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row + 2, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row + 2, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row + 1, col + 2, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row - 1, col + 2, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row - 2, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row - 2, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindKnightsPathWords(row - 1, col - 2, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
            }

            this.rows[row][col].visited = false;
            this.positions.pop();
            return solutions;
        };


        Grid.prototype.FindBoggleSolutions = function (row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if ((row < 0) && (col < 0)) {
                for (row = 0; row < this.height; row++) {
                    for (col = 0; col < this.width; col++) {
                        solutions = solutions.concat(this.FindBoggleSolutions(row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                    }
                }
            }
            else {
                var startIndex = 0;
                var endIndex = wordLengths.length;
                var indexAdj = 1;
                var index = startIndex;

                if (searchBackwards) {
                    startIndex = wordLengths.length - 1;
                    endIndex = 0;
                    indexAdj = -1
                    index = startIndex;
                }

                for (var i = 0; i < wordLengths.length; i++) {
                    if ((wordLengths.length > 1) || wordLengths[index] != 0) {
                        minWordLength = wordLengths[index];
                        maxWordLength = wordLengths[index];
                    }

                    if (index == startIndex) {
                        solutions = this.FindBoggleWords(row, col, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency);
                    }
                    else {
                        if (hasSpaces) {
                            // Find solutions based on each of the previous solutions where a space exists after the word.
                            //
                            var newSolutions = [];

                            for (var j = 0; j < solutions.length; j++) {
                                var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                                var row = lastCell.row;
                                var col = lastCell.col;

                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col - 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col + 0));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row - 1, col + 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 0, col + 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col + 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col + 0));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 1, col - 1));
                                newSolutions = newSolutions.concat(solutions[j].getSpaceSolutions(row + 0, col - 1));
                            }

                            solutions = newSolutions;
                        }

                        var newSolutions = [];
                        for (var j = 0; j < solutions.length; j++) {
                            // Find solutions based on each of the previous solutions words that have been found.
                            //
                            var tempSolutions = [];
                            var lastCell = solutions[j].grid.positions[solutions[j].grid.positions.length - 1];
                            var row = lastCell.row;
                            var col = lastCell.col;

                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row - 1, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row - 1, col + 0, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row - 1, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row + 0, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row + 1, col + 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row + 1, col + 0, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row + 1, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                            tempSolutions = tempSolutions.concat(solutions[j].grid.FindBoggleWords(row + 0, col - 1, "", searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));

                            for (var k = 0; k < tempSolutions.length; k++) {
                                if (searchBackwards) {
                                    tempSolutions[k].word.value = tempSolutions[k].word.value + " " + solutions[j].word.value;
                                }
                                else {
                                    tempSolutions[k].word.value = solutions[j].word.value + " " + tempSolutions[k].word.value;
                                }
                                tempSolutions[k].word.frequency = (solutions[j].word.frequency + tempSolutions[k].word.frequency) / 2;
                            }

                            newSolutions = newSolutions.concat(tempSolutions);
                        }
                        solutions = newSolutions;
                    }

                    index = index + indexAdj;
                }
            }

            return solutions;
        }

        Grid.prototype.FindBoggleWords = function (row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (!this.IsValid(row, col)) {
                return solutions;
            }

            if (searchBackwards) {
                text = this.rows[row][col].value + text;
            }
            else {
                text = text + this.rows[row][col].value;
            }

            if (maxWordLength && (text.length > maxWordLength)) {
                return solutions;
            }

            this.rows[row][col].visited = true;
            this.positions.push(new GridPosition(row, col));

            if (text.length >= minWordLength) {
                var words = PHTWords.GetWordMatches(PHTWords.EscapeString(text), null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength);
                if (words.length == 1) {
                    solutions.push(new GridSolution(new Grid(this), words[0]));
                }
            }

            if (this.ContinueSearching(row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency)) {
                solutions = solutions.concat(this.FindBoggleWords(row - 1, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row - 1, col + 0, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row - 1, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row + 0, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row + 1, col + 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row + 1, col + 0, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row + 1, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                solutions = solutions.concat(this.FindBoggleWords(row + 0, col - 1, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
            }

            this.rows[row][col].visited = false;
            this.positions.pop();
            return solutions;
        }

        Grid.prototype.FindLtrSkipSolutions = function (row, col, searchBackwards, wordLengths, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (wordLengths && wordLengths[0]) {
                minWordLength = wordLengths[0];
                maxWordLength = wordLengths[0];
            }

            if ((row >= 0) && (col >= 0)) {
                if (getHorizontalSearch()) {
                    for (var i = col; i < this.width; i++) {
                        solutions = solutions.concat(this.FindLtrSkipSearchWords("", row, i, +0, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                    }
                }

                if (getVerticalSearch()) {
                    for (var i = row; i < this.height; i++) {
                        solutions = solutions.concat(this.FindLtrSkipSearchWords("", i, col, +1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                    }
                }
            }
            else {
                if (getHorizontalSearch()) {
                    for (var row = 0; row < this.height; row++) {
                        for (var col = 0; col < this.width; col++) {
                            solutions = solutions.concat(this.FindLtrSkipSearchWords("", row, col, +0, +1, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        }
                    }
                }

                if (getVerticalSearch()) {
                    for (var col = 0; col < this.width; col++) {
                        for (var row = 0; row < this.height; row++) {
                            solutions = solutions.concat(this.FindLtrSkipSearchWords("", row, col, +1, +0, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                        }
                    }
                }
            }

            return solutions;
        }

        Grid.prototype.FindLtrSkipSearchWords = function (text, row, col, rowAdj, colAdj, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency) {
            var solutions = [];

            if (!this.IsValid(row, col)) {
                return solutions;
            }

            if (searchBackwards) {
                text = this.rows[row][col].value + text;
            }
            else {
                text = text + this.rows[row][col].value;
            }

            if (maxWordLength && (text.length > maxWordLength)) {
                return solutions;
            }

            this.rows[row][col].visited = true;
            this.positions.push(new GridPosition(row, col));

            if (text.length >= minWordLength) {
                var words = PHTWords.GetWordMatches(PHTWords.EscapeString(text), null, null, null, null, dictionaries, minFrequency, 1, minWordLength, maxWordLength);
                if (words.length == 1) {
                    solutions.push(new GridSolution(new Grid(this), words[0]));
                }
            }

            if (this.ContinueSearching(row, col, text, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency)) {
                var startRow = row;
                var startCol = col;
                while ((startRow < this.height) && (startCol < this.width)) {
                    startRow += rowAdj;
                    startCol += colAdj;
                    solutions = solutions.concat(this.FindLtrSkipSearchWords(text, startRow, startCol, rowAdj, colAdj, searchBackwards, hasSpaces, minWordLength, maxWordLength, dictionaries, minFrequency));
                }
            }

            this.rows[row][col].visited = false;
            this.positions.pop();
            return solutions;
        }

        //
        // GridPosition object declaration
        //
        function GridPosition(row, col) {
            this.row = row;
            this.col = col;
        }

        ///
        /// GridSolution object declaration
        ///
        function GridSolution(grid, word) {
            this.grid = grid;
            this.word = word;
        }

        GridSolution.prototype.getSpaceSolutions = function (row, col) {
            var solutions = [];

            if (row < 0 || col < 0 || row >= this.grid.height || col >= this.grid.width || this.grid.rows[row][col].visited || (this.grid.rows[row][col].value != ' ')) {
                return solutions;
            }

            var grid = new Grid(this.grid);
            grid.rows[row][col].visited = true;
            grid.positions.push(new GridPosition(row, col));
            solutions.push(new GridSolution(grid, this.word));

            return solutions;
        }


        //
        // Comparison Methods
        //
        function CompareGridPosition(a, b) {
            var result = 0;

            if (a.row > b.row) {
                result = 1;
            }
            else if (a.row < b.row) {
                result = -1;
            }
            else {
                if (a.col > b.col) {
                    result = 1;
                }
                else if (a.col < b.col) {
                    result = -1;
                }
            }

            return result;
        }

        function CompareGridSolutionPaths(a, b) {
            var result = 0;

            for (var i = 0; i < a.grid.positions.length && i < b.grid.positions.length; i++) {
                result = CompareGridPosition(a.grid.positions[i], b.grid.positions[i]);
                if (result != 0) {
                    break;
                }
            }

            if ((result == 0) && (a.grid.positions.length != b.grid.positions.length)) {
                if (a.grid.positions.length < b.grid.positions.length) {
                    result = 1;
                }
                else {
                    result = -1;
                }
            }

            return result;
        }

        function CompareGridSolutionWords(a, b) {
            var result = 0;

            if (a.word.value > b.word.value) {
                result = 1;
            }
            else if (a.word.value < b.word.value) {
                result = -1;
            }

            return result;
        }

        function CompareGridSolutionFrequency(a, b) {
            var result = 0;

            if (a.word.frequency > b.word.frequency) {
                return 1;
            }
            else if (a.word.frequency < b.word.frequency) {
                return -1;
            }

            return CompareGridSolutionWords(a, b);
        }

        function CompareGridSolutionLengths(a, b) {
            var result = 0;

            if (a.word.value.length > b.word.value.length) {
                return 1;
            }
            else if (a.word.value.length < b.word.value.length) {
                return -1;
            }

            return CompareGridSolutionWords(a, b);
        }




    </script>
</head>
<body onload="renderGrid();">

    <table style="width:100%;">
        <tr>
            <td style="width:50%; vertical-align:top; border-right: 3px solid black; border-left: 3px solid black; padding-left:5px; padding-right:10px;">
                <table style="width: 100%">
                    <tr>
                        <td style="white-space: nowrap;" colspan="3">
                            Options:
                            <label><input type="checkbox" id="CluedWords" value="1" />Clued Words</label>
                            <label><input type="checkbox" id="AnagramFill" value="1" />Anagram Fill</label>
                            <label><input type="checkbox" id="LooseFit" value="1" onclick="doUpdateGridText();" />Loose Fit</label>
                            <br />
                            Fit&nbsp;Words:
                            <label><input type="checkbox" id="HorizontalFit" checked="checked" value="1" />Horizontal</label>
                            <label><input type="checkbox" id="VerticalFit" checked="checked" value="1" />Vertical</label>
                            <hr />
                        </td>
                    </tr>
                    <tr>
                        <td style="white-space: nowrap;" colspan="3">
                            <label><input type="radio" name="Direction" id="Start" checked="checked" value="Forward" />Start</label>
                            <label><input type="radio" name="Direction" id="End" value="Backwards"  />End</label>
                            <input type="text" id="StartCell" size="8" onkeyup="renderGrid();" value="" />
                            <label>Words&nbsp;Breaks:<input type="text" id="WordBreaks" size="20" value="" /></label>
                            <label><input type="checkbox" id="HasSpaces" value="1" />Has&nbsp;Spaces</label>
                            <hr />
                        </td>
                    </tr>
                    <tr>
                        <td style="white-space: nowrap;">
                            <label>Min Length: <input type="text" id="MinWordLength" value="3" style="width:2em;"/></label>
                            <label>Max Length: <input type="text" id="MaxWordLength" value=""  style="width:2em;"/></label>
                        </td>
                        <td style="text-align:right;white-space:nowrap;">
                            <label style="display:none;" id="HorizontalWrapLabel"><input type="checkbox" id="HorizontalWrap" value="1" />H-Wrap</label>
                            <label style="display:none;" id="VerticalWrapLabel"><input type="checkbox" id="VerticalWrap" value="1" />V-Wrap</label>
                            <label style="display:none;" id="HorizontalSearchLabel"><input type="checkbox" id="HorizontalSearch" checked="checked" value="1" />H-Search</label>
                            <label style="display:none;" id="VerticalSearchLabel"><input type="checkbox" id="VerticalSearch" value="1" />V-Search</label>
                            <label><input type="checkbox" id="AutoClear" checked="checked" value="1" />Auto&nbsp;Clear</label>
                        </td>
                        <td style="text-align:right;">
                            <button onclick="doSearch();">Search</button>
                        </td>
                    </tr>
                </table>
                <hr />

                <span>Grid: </span><span id="GridDimensions"></span>
                <table id="GridTable" class="GridTable"></table>
                
                <br />
                <hr />
                <span>Words:</span>
                <textarea id="Words" style="width:100%;height:250px;font-family:Courier New, Courier, monospace;font-size:12px;" ></textarea>
                <hr />
                <span>Grid Text:</span>
                <label><input type="text" id="SeperatorToken" value="#" onkeyup="doUpdateGridText()" style="width:1em;"/>Seperator</label>
                <label><input type="text" id="SpaceToken" value="_" onkeyup="doUpdateGridText()" style="width:1em;"/>Space</label>
                <label><input type="text" id="RequiredToken" value="!" onkeyup="doUpdateGridText()" style="width:1em;"/>Required</label>
                <br />
                <br />
                <textarea id="GridText" style="width:100%;height:250px;font-family:Courier New, Courier, monospace;font-size:12px;" onkeyup="doUpdateGridText();"></textarea>
            </td>
            <td style="width:50%; vertical-align:top;">
                <table style="width: 100%">
                    <tr>
                        <td style="white-space: nowrap;" colspan="2">
                            <span>Dictionary:</span>
                            <label><input type="checkbox" id="ModernEnglish" value="1" />Modern&nbsp;English</label>
                            <label><input type="checkbox" id="MiddleEnglish" value="2" />Middle&nbsp;English</label>
                            <label><input type="checkbox" id="WordList" checked="checked" value="-1" />Word&nbsp;List</label>
                            <hr />
                        </td>
                    </tr>
                    <tr>
                        <td style="white-space: nowrap;" colspan="2">
                            <label>Min&nbsp;Frequency: <input type="text" id="MinFrequency" size="10" value="1" title="Modern English (BNC):
  0 = 700,000 words
  1 = 80,000 words
  15 = 60,000 words
  50 = 40,000 words
  200 = 20,000 words
  500 = 10,000 words
  1500 = 5,000 words
  4000 = 2,500 words
  10000 = 1,000 words
" /></label>
                            <br />
                            <hr />
                        </td>
                    </tr>
                    <tr>
                        <td style="white-space: nowrap;" colspan="1">
                            <label>Results: <input type="text" size="5" disabled="disabled" id="ResultsCount" /></label>
                            <label>Duration: <input type="text" size="12" disabled="disabled" id="Duration" /></label>
                        </td>
                        <td style="white-space: nowrap;text-align:right;">
                            <button onclick="doClearSolutions(true);">Clear&nbsp;Unselected</button>
                            <button onclick="doClearSolutions(false);">Clear&nbsp;All</button>
                        </td>
                    </tr>
                </table>

                <hr />

                <div style="border:1px solid black;">
                    <table id="ResultsHeader" style="width:100%;">
                        <tr>
                            <th style="text-align:left;">
                                <a href="javascript:void(0)" onclick="doSortByWords();">Alphabetical</a>
                                <a href="javascript:void(0)" onclick="doSortByLength();">Length</a>
                            </th>
                            <th style="text-align:right;"><a href="javascript:void(0)" onclick="doSortByFrequency();">Frequency</a></th>
                        </tr>
                    </table>
                </div>
                <div style="height:460px;overflow-y:auto;border:1px solid black;">
                    <table id="ResultsTable" style="width:100%;"></table>
                </div>

                <br />
                <span>Word List:</span>
                <label><input type="checkbox" id="LinesAsWords" onclick="doGetWordList();" checked="checked" value="1" />Lines Are Words</label>
                <textarea id="WordListText" style="width:100%;height:250px;font-family:Courier New, Courier, monospace;font-size:12px;" onkeyup="doGetWordList();"></textarea>
            </td>
        </tr>
    </table>

</body>
</html>
